<BOOL>: bool
<ID>: isPowerOfTwo
<LEFT_ROUND_B>: (
<INT>: int
<ID>: x
<RIGHT_ROUND_B>: )
<LEFT_CURLY_B>: {
<MULTI_COMMENT>: /*
    Try multiline comment
    */
<SINGLE_COMMENT>: // First x in the below expression is
<SINGLE_COMMENT>: // for the case when x is 0
<FLOAT>: float
<ID>: f
<SEMICOLON>: ;
<ID>: f
<ASSIGNMENT>: =
<FlOAT_LITERAL>: 0.65
<SEMICOLON>: ;
<SINGLE_COMMENT>: // extra added to rules
<INT>: int
<ID>: x
<SEMICOLON>: ;
<ID>: x
<ASSIGNMENT>: =
<INTEGRAL_LITERAL>: 5
<SEMICOLON>: ;
<INT>: int
<ID>: y
<SEMICOLON>: ;
<ID>: y
<ASSIGNMENT>: =
<INTEGRAL_LITERAL>: 6
<SEMICOLON>: ;
<INT>: int
<ID>: z
<SEMICOLON>: ;
<ID>: z
<ASSIGNMENT>: =
<ID>: x
<SEMICOLON>: ;
<SINGLE_COMMENT>: // string hi = "hiasjfn;lwqmef;qwefqewf"; NOT IN GRAMMAR RULES SENT
<CHAR>: char
<ID>: k
<SEMICOLON>: ;
<ID>: k
<ASSIGNMENT>: =
<CHAT_LITERAL>: 'k'
<SEMICOLON>: ;
<BOOL>: bool
<ID>: f
<SEMICOLON>: ;
<ID>: f
<ASSIGNMENT>: =
<BOOL_LITERAL>: true
<SEMICOLON>: ;
<INT>: int
<ID>: arr
<LEFT_SQUARE_B>: [
<RIGHT_SQUARE_B>: ]
<SEMICOLON>: ;
<ID>: arr
<ASSIGNMENT>: =
<NEW>: new
<INT>: int
<LEFT_SQUARE_B>: [
<INTEGRAL_LITERAL>: 10
<RIGHT_SQUARE_B>: ]
<SEMICOLON>: ;
<ID>: z
<ASSIGNMENT>: =
<ID>: x
<PLUS>: +
<ID>: y
<SEMICOLON>: ;
<RETURN>: return
<ID>: x
<AND>: &&
<LEFT_ROUND_B>: (
<NOT>: !
<LEFT_ROUND_B>: (
<ID>: x
<BITWISE_AND>: &
<LEFT_ROUND_B>: (
<ID>: x
<MINUS>: -
<INTEGRAL_LITERAL>: 1
<RIGHT_ROUND_B>: )
<RIGHT_ROUND_B>: )
<RIGHT_ROUND_B>: )
<SEMICOLON>: ;
<RIGHT_CURLY_B>: }
